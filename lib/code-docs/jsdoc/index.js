'use strict';

const ClassNode = require('./nodes/class');
const EventNode = require('./nodes/event');
const FunctionNode = require('./nodes/function');
const MixinNode = require('./nodes/mixins');
const NamespaceNode = require('./nodes/namespace');
const PropertyNode = require('./nodes/property');
const ModuleNode = require('./nodes/module');

/**
 * Methods to prepare JsDoc json doclets for display within the registry.
 */
class JsDoc {
    /**
     * @returns {string[]} Kinds of JSDoc doclets which are supported.
     */
    static supportedDoclets() {
        return ['class', 'function', 'constant', 'member', 'event', 'namespace', 'mixin', 'module'];
    }

    /**
     * Format a doclet by removing superfluous properties and adding any custom properties.
     * @param {Object} doclet - A raw json doclet generated by JSDoc.
     * @returns {Object} Formatted node.
     */
    static formatDoclet(doclet) {
        switch (doclet.kind) {
            case 'class':
                return new ClassNode(doclet);
                break;
            case 'function':
                return new FunctionNode(doclet);
                break;
            case 'constant':
            case 'member':
                return new PropertyNode(doclet);
                break;
            case 'event':
                return new EventNode(doclet);
                break;
            case 'namespace':
                return new NamespaceNode(doclet);
                break;
            case 'mixin':
                return new MixinNode(doclet);
                break;
            case 'module':
                return new ModuleNode(doclet);
                break;
            default:
                throw new Error(`JsDoc doclet kind "${doclet.kind}" is not supported by the registry.`);
                break;
        };
    }

    /**
     * Filter doclets which are not supported or should not be displayed.
     * @param {Object[]} doclets - Raw json doclets generated by JSDoc.
     * @returns {Object[]} Filtered doclets.
     */
    static filterDoclets(doclets) {
        return doclets.filter((doclet) => {
            const isNotIndicatedPrivate = doclet.name && doclet.name.indexOf('_') !== 0; // @todo mark as private in repo-data
            const isSupported = doclet.kind && JsDoc.supportedDoclets().includes(doclet.kind);
            const isPublic = doclet.access !== 'private';
            const isDocumented = doclet.undocumented !== true;
            return isSupported && isPublic && isNotIndicatedPrivate && isDocumented;
        });
    }

    /**
     * Format multiple doclets.
     * @param {Object[]} doclets - Raw json doclets generated by JSDoc.
     * @returns {Object[]} Formatted nodes.
     * @throws Will throw an error if a doclet is passed which is unsupported. Filter unsuported doclets first.
     * @see filterDoclets
     */
    static formatDoclets(doclets) {
        return doclets.map((doclet) => {
            return JsDoc.formatDoclet(doclet);
        });
    }

    /**
     * Format doclets and add members to parent nodes. E.g. add function nodes to their corresponding class node.
     * @param {Object[]} doclets [{}] - Raw json doclets generated by JSDoc.
     * @param {Object|Object[]} parentNodes - Root nodes to add member nodes to (optional).
     * @returns {Object[]} Nodes with member nodes grouped by kind e.g. {name: 'Example', type: class, examples: [{}], functions: [{}], properties: [{}]}
     */
    static formatWithHierarchy(doclets, parentNodes = {}) {
        parentNodes = Array.isArray(parentNodes) ? parentNodes : [parentNodes];
        const nodesWithHierarchy = parentNodes.map((parentNode) => {
            doclets = JsDoc.filterDoclets(doclets);
            const nodes = JsDoc.formatDoclets(doclets)
                .filter((node) => node.memberof === parentNode.longname);
            return nodes.reduce((parentNode, node) => {
                JsDoc.formatWithHierarchy(doclets, node);
                parentNode[node.group] = parentNode[node.group] || [];
                parentNode[node.group].push(node);
                return parentNode;
            }, parentNode);
        });
        return (nodesWithHierarchy.length === 1 ? nodesWithHierarchy[0] : nodesWithHierarchy);
    }
}

module.exports = JsDoc;
