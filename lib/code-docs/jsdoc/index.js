'use strict';

const ClassNode = require('./nodes/class');
const EventNode = require('./nodes/event');
const FunctionNode = require('./nodes/function');
const MixinNode = require('./nodes/mixin');
const TypedefNode = require('./nodes/typedef');
const NamespaceNode = require('./nodes/namespace');
const PropertyNode = require('./nodes/property');
const ModuleNode = require('./nodes/module');

/**
 * Methods to prepare JsDoc json doclets for display within the registry.
 */
class JsDoc {
    /**
     * @param {Object[]} doclets - Raw json doclets generated by JSDoc.
     */
    constructor(doclets) {
        this.doclets = doclets;
    }

    /**
     * @returns {string[]} Kinds of JSDoc doclets which are supported.
     */
    static supportedDocletKinds() {
        return ['class', 'function', 'constant', 'member', 'event', 'namespace', 'mixin', 'module', 'typedef'];
    }

    /**
     * Format a doclet by removing superfluous properties and adding any custom properties.
     * @param {Object} doclet - A raw json doclet generated by JSDoc.
     * @returns {Object} Formatted node.
     */
    formatDoclet(doclet) {
        // JSDoc does not indicate if a parameter is a custom type which is documented.
        // I.e. a parameter of type "MyCallbackFunction" may have a doclet of its own which we can link to.
        // So add a custom `types` property to JSDoc doclets.
        if (Array.isArray(doclet.params)) {
            doclet.params.map((param) => {
                param.types = param.type && param.type.names ? param.type.names.map((type) => {
                    const paramDoclet = this.doclets.find(doclet => doclet.longname === type);
                    return {
                        name: type,
                        longname: paramDoclet && JsDoc.supportedDoclet(paramDoclet) ? paramDoclet.longname : null
                    };
                }) : [];
                return param;
            });
        }
        switch (doclet.kind) {
            case 'class':
                return new ClassNode(doclet);
                break;
            case 'function':
                return new FunctionNode(doclet);
                break;
            case 'constant':
            case 'member':
                return new PropertyNode(doclet);
                break;
            case 'event':
                return new EventNode(doclet);
                break;
            case 'namespace':
                return new NamespaceNode(doclet);
                break;
            case 'mixin':
                return new MixinNode(doclet);
                break;
            case 'typedef':
                return new TypedefNode(doclet);
                break;
            case 'module':
                return new ModuleNode(doclet);
                break;
            default:
                throw new Error(`JsDoc doclet kind "${doclet.kind}" is not supported by the registry.`);
                break;
        };
    }

    /**
     * @returns {Object[]} Formatted nodes.
     */
    getNodes() {
        if (!this._formattedDoclets) {
            const supportedDoclets = this.doclets.filter(JsDoc.supportedDoclet);

            this._formattedDoclets = supportedDoclets.map((doclet) => {
                return this.formatDoclet(doclet);
            });
        }
        return this._formattedDoclets;
    }

    static supportedDoclet(doclet) {
        const isNotIndicatedPrivate = doclet.name && doclet.name.indexOf('_') !== 0;
        const isSupported = doclet.kind && JsDoc.supportedDocletKinds().includes(doclet.kind);
        const isPublic = doclet.access !== 'private';
        const isDocumented = doclet.undocumented !== true;
        return isSupported && isPublic && isNotIndicatedPrivate && isDocumented;
    }

    /**
     * @returns {Object[]} Formatted nodes.
     */
    getNodesByTypeWithMembers() {
        if (!this._formattedDocletsWithMembers) {
            this._formattedDocletsWithMembers = JsDoc._addChildNodes(this.getNodes(), {});
        }
        return this._formattedDocletsWithMembers;
    }

    /**
     * Add member nodes to parent nodes. E.g. add function nodes to their corresponding class node.
     * @param {Object[]} nodes [{}] - Formatted JSDoc doclets.
     * @param {Object|Object[]} parentNodes - Root nodes to add member nodes to (optional).
     * @returns {Object[]} Nodes with member nodes grouped by kind e.g. {name: 'Example', type: class, examples: [{}], functions: [{}], properties: [{}]}
     * @access private
     */
    static _addChildNodes(nodes, parentNodes = {}) {
        parentNodes = Array.isArray(parentNodes) ? parentNodes : [parentNodes];
        const nodesWithMembers = parentNodes.map((parentNode) => {
            const memberNodes = nodes.filter((node) => node.memberof === parentNode.longname);
            return memberNodes.reduce((parentNode, node) => {
                JsDoc._addChildNodes(nodes, node);
                parentNode[node.group] = parentNode[node.group] || [];
                parentNode[node.group].push(node);
                return parentNode;
            }, parentNode);
        });
        return (nodesWithMembers.length === 1 ? nodesWithMembers[0] : nodesWithMembers);
    }
}

module.exports = JsDoc;
